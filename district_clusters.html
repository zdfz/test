<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>District Clustering Tool</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://cdn.jsdelivr.net/npm/ml-kmeans@4.0.0/dist/ml-kmeans.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }

        .container {
            width: 100%;
            padding: 20px;
        }

        .content {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 20px;
        }

        .header h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 20px;
            font-size: 2rem;
            font-weight: 600;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .input-group label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }

        .input {
            width: 80px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 8px;
            text-align: center;
            font-size: 1rem;
            font-weight: bold;
        }

        .button-group {
            display: flex;
            gap: 15px;
        }

        .button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .main-content {
            max-width: 1200px;
            margin: 20px auto;
            display: flex;
            gap: 20px;
            padding: 0 20px;
        }

        .map-container {
            flex: 2;
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            min-height: 600px;
        }

        #map {
            width: 100%;
            height: 600px;
        }

        .sidebar {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            max-height: 600px;
            overflow-y: auto;
        }

        .sidebar h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.3rem;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .cluster-info {
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-card .number {
            font-size: 1.5rem;
            font-weight: bold;
            display: block;
        }

        .stat-card .label {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        .error-message {
            background: #ff6b6b;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .success-message {
            background: #51cf66;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-weight: 600;
        }

        .loading.show {
            display: block;
        }

        .district-tag {
            display: inline-block;
            background-color: #e9ecef;
            color: #495057;
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.9em;
            margin: 3px;
            white-space: nowrap;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .controls {
                flex-direction: column;
                gap: 15px;
            }
            
            .input-group {
                flex-direction: column;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <div class="header">
                <h1>üó∫Ô∏è District Clustering Tool</h1>
            </div>
            
            <div class="controls">
                <div class="input-group">
                    <label for="vansInput">Number of Vans</label>
                    <input type="number" min="1" value="10" class="input" id="vansInput">
                </div>
                <div class="input-group">
                    <label for="parcelsInput">Max Parcels/Van</label>
                    <input type="number" min="1" value="50" class="input" id="parcelsInput">
                </div>
                <div class="button-group">
                    <button class="button" id="generateBtn" onclick="generateClusters()">
                        Generate Clusters
                    </button>
                    <button class="button" id="calculateShiftsBtn" onclick="calculateShifts()">
                        Calculate Shifts
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div class="map-container">
            <div id="map"></div>
        </div>
        
        <div class="sidebar">
            <div class="error-message" id="errorMessage"></div>
            <div class="success-message" id="successMessage"></div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <span class="number" id="totalDistricts">0</span>
                    <span class="label">Districts</span>
                </div>
                <div class="stat-card">
                    <span class="number" id="totalClusters">0</span>
                    <span class="label">Clusters</span>
                </div>
                <div class="stat-card">
                    <span class="number" id="totalOrders">0</span>
                    <span class="label">Total Orders</span>
                </div>
            </div>
            
            <h3>üìä Cluster Summary</h3>
            <div class="loading" id="loading">
                <p>üîÑ Processing data...</p>
            </div>
            <div id="clusterSummary">
                <p style="text-align: center; color: #666; font-style: italic;">
                    Generate clusters to see summary.
                </p>
            </div>

            <h3>üöö Shift Calculation</h3>
            <div id="shiftSummary">
                <p style="text-align: center; color: #666; font-style: italic;">
                    Enter van and parcel info to calculate shifts.
                </p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        // Global variables
        const clusterColors = [
            "#e6194b", "#3cb44b", "#ffe119", "#4363d8", "#f58231", "#911eb4", 
            "#46f0f0", "#f032e6", "#bcf60c", "#fabebe", "#008080", "#e6beff", 
            "#9a6324", "#fffac8", "#800000", "#aaffc3", "#808000", "#ffd8b1", 
            "#000075", "#808080", "#AA6E28", "#B57EDC", "#C0C0C0", "#FFD700",
            "#00FF00", "#00FFFF", "#FF00FF", "#8A2BE2", "#A52A2A", "#DEB887"
        ];
        
        let map;
        let currentData = null;
        let currentClusters = [];
        let districtLayers = [];

        // Add a color palette for shifts
        const shiftColors = [
            '#43a047', // green
            '#1976d2', // blue
            '#fbc02d', // yellow
            '#e64a19', // orange
            '#8e24aa', // purple
            '#00838f', // teal
            '#c62828', // red
            '#6d4c41', // brown
            '#3949ab', // indigo
            '#00acc1'  // cyan
        ];

        // Store van/shift assignments globally
        let shiftAssignments = [];

        // Initialize application
        function initApp() {
            initMap();
            setupEventListeners();
            loadExcelFile();
        }

        // Initialize map
        function initMap() {
            try {
                map = L.map('map').setView([26.3927, 50.0981], 11);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(map);
            } catch (error) {
                showError('Error initializing map: ' + error.message);
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            // No-op for now, can be used for future event listeners
        }

        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => errorDiv.style.display = 'none', 8000);
        }

        // Show success message
        function showSuccess(message) {
            const successDiv = document.getElementById('successMessage');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            setTimeout(() => successDiv.style.display = 'none', 5000);
        }

        // Load Excel file
        function loadExcelFile() {
            const loading = document.getElementById('loading');
            loading.classList.add('show');

            fetch('RUH - Polygons v2 2506.xlsx')
                .then(response => {
                    if (!response.ok) throw new Error(`Could not load Excel file. Status: ${response.status}`);
                    return response.arrayBuffer();
                })
                .then(data => {
                    try {
                        const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
                        let allDistricts = processWorkbook(workbook);
                        allDistricts = allDistricts.map((d, index) => ({ ...d, id: index }));
                        if (allDistricts.length === 0) {
                            throw new Error('No valid districts found in the Excel file.');
                        }
                        currentData = allDistricts;
                        updateStats();
                        updateMapWithDistricts();
                        showSuccess(`Loaded ${allDistricts.length} districts successfully!`);
                    } catch (error) {
                        showError('Error processing Excel file: ' + error.message);
                    } finally {
                        loading.classList.remove('show');
                    }
                })
                .catch(error => {
                    showError('Error loading Excel file: ' + error.message);
                    loading.classList.remove('show');
                });
        }

        // Process workbook data
        function processWorkbook(workbook) {
            let allDistricts = [];
            
            workbook.SheetNames.forEach(sheetName => {
                try {
                    const sheet = workbook.Sheets[sheetName];
                    const sheetData = XLSX.utils.sheet_to_json(sheet);
                    const districts = processSheetData(sheetData, sheetName);
                    allDistricts = allDistricts.concat(districts);
                } catch (sheetError) {
                    console.error(`Error processing sheet "${sheetName}":`, sheetError);
                }
            });
            
            return allDistricts;
        }

        // Process sheet data
        function processSheetData(sheetData, cityName) {
            return sheetData
                .map((row, index) => {
                    try {
                        const districtName = row['name_en'] || `District ${index + 1}`;
                        const wktOrGeoJson = row['WKT'];
                        const orderQty = parseInt(row['order_qty'] || 0, 10);
                        if (!wktOrGeoJson) return null;
                        const geoJson = parseGeoJson(wktOrGeoJson);
                        if (!geoJson) return null;
                        const { coords, isValid } = getGeoJsonCoordinates(geoJson);
                        if (!isValid) return null;
                        const { centroidLat, centroidLng } = calculateCentroid(coords);
                        if (isNaN(centroidLat)) return null;
                        return {
                            name: districtName,
                            city: 'Riyadh',
                            geoJson: geoJson,
                            lat: centroidLat,
                            lng: centroidLng,
                            orderQty: orderQty,
                            area: calculatePolygonArea(coords)
                        };
                    } catch (error) {
                        console.error(`Error processing district ${index}:`, error);
                        return null;
                    }
                })
                .filter(Boolean);
        }

        // Find value in row with flexible column name matching
        function findColumnValue(row, possibleNames) {
            for (const name of possibleNames) {
                if (row[name] !== null && row[name] !== undefined && row[name] !== '') {
                    return row[name];
                }
            }
            return null;
        }

        // Enhanced parseGeoJson to handle both GeoJSON and WKT POLYGON
        function parseGeoJson(geoJsonStr) {
            try {
                // If it's already an object, return as is
                if (typeof geoJsonStr === 'object') return geoJsonStr;
                // Try to parse as JSON
                if (geoJsonStr.trim().startsWith('{') || geoJsonStr.trim().startsWith('[')) {
                    return JSON.parse(geoJsonStr);
                }
                // Try to parse as WKT POLYGON
                if (geoJsonStr.trim().toUpperCase().startsWith('POLYGON')) {
                    // Extract the coordinates string
                    const match = geoJsonStr.match(/POLYGON *\(\(([^)]+)\)\)/i);
                    if (match && match[1]) {
                        // Split into coordinate pairs
                        const pairs = match[1].split(',').map(s => s.trim().split(/\s+/).map(Number));
                        // WKT is [lng, lat], so keep as is
                        return {
                            type: 'Polygon',
                            coordinates: [pairs]
                        };
                    }
                }
                // If not recognized, return null
                return null;
            } catch (e1) {
                // Try to clean up and parse as JSON
                try {
                    const cleaned = geoJsonStr
                        .replace(/^"|"$/g, '')
                        .replace(/""/g, '"');
                    return JSON.parse(cleaned);
                } catch (e2) {
                    return null;
                }
            }
        }

        // Get coordinates from GeoJSON
        function getGeoJsonCoordinates(geoJson) {
            let coords;
            
            if (geoJson.type === 'Polygon') {
                coords = geoJson.coordinates[0];
            } else if (geoJson.type === 'MultiPolygon') {
                coords = geoJson.coordinates[0][0];
            } else {
                return { coords: null, isValid: false };
            }
            
            const isValid = Array.isArray(coords) && coords.length >= 3;
            return { coords, isValid };
        }

        // Calculate centroid from coordinates
        function calculateCentroid(coords) {
            let totalLat = 0, totalLng = 0;
            
            coords.forEach(coord => {
                if (Array.isArray(coord) && coord.length >= 2) {
                    totalLng += parseFloat(coord[0]);
                    totalLat += parseFloat(coord[1]);
                }
            });
            
            return {
                centroidLat: totalLat / coords.length,
                centroidLng: totalLng / coords.length
            };
        }

        // Calculate polygon area
        function calculatePolygonArea(coordinates) {
            if (!coordinates || coordinates.length < 3) return 0;
            
            let area = 0;
            const n = coordinates.length;
            
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += coordinates[i][0] * coordinates[j][1];
                area -= coordinates[j][0] * coordinates[i][1];
            }
            
            const earthRadius = 6371;
            return (Math.abs(area) / 2) * (Math.PI / 180) ** 2 * earthRadius ** 2;
        }

        // Update statistics display
        function updateStats() {
            if (!currentData) return;
            
            document.getElementById('totalDistricts').textContent = currentData.length;
            document.getElementById('totalClusters').textContent = currentClusters.length > 0 
                ? new Set(currentClusters).size 
                : 0;
            document.getElementById('totalOrders').textContent = currentData.reduce((sum, d) => sum + d.orderQty, 0);
        }

        // Update map with districts
        function updateMapWithDistricts() {
            if (!map || !currentData || currentData.length === 0) return;
            clearMapLayers();
            const bounds = L.latLngBounds([]);
            // Collect centroids
            const centroids = currentData.map(d => [d.lat, d.lng]);
            // Calculate mean and stddev
            const meanLat = centroids.reduce((sum, c) => sum + c[0], 0) / centroids.length;
            const meanLng = centroids.reduce((sum, c) => sum + c[1], 0) / centroids.length;
            const stdLat = Math.sqrt(centroids.reduce((sum, c) => sum + Math.pow(c[0] - meanLat, 2), 0) / centroids.length);
            const stdLng = Math.sqrt(centroids.reduce((sum, c) => sum + Math.pow(c[1] - meanLng, 2), 0) / centroids.length);
            // Only include centroids within 2 stddevs
            const filteredCentroids = centroids.filter(c =>
                Math.abs(c[0] - meanLat) <= 2 * stdLat &&
                Math.abs(c[1] - meanLng) <= 2 * stdLng
            );
            currentData.forEach(district => {
                const layer = createDistrictLayer(district);
                if (layer) {
                    districtLayers.push(layer);
                    if (layer.getBounds) {
                        bounds.extend(layer.getBounds());
                    } else if (layer.getLatLng) {
                        bounds.extend(layer.getLatLng());
                    }
                }
            });
            // Fit to filtered centroids
            if (filteredCentroids.length > 0) {
                const centroidBounds = L.latLngBounds(filteredCentroids);
                map.fitBounds(centroidBounds, { padding: [20, 20] });
            } else if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [20, 20] });
            }
        }

        // Clear all map layers
        function clearMapLayers() {
            districtLayers.forEach(layer => {
                if (map.hasLayer(layer)) {
                    map.removeLayer(layer);
                }
            });
            districtLayers = [];
        }

        // Create district layer for map
        function createDistrictLayer(district) {
            try {
                if (district.geoJson?.coordinates) {
                    const leafletCoords = convertGeoJsonToLeaflet(district.geoJson);
                    const polygon = L.polygon(leafletCoords, {
                        color: '#333',
                        weight: 2,
                        fillColor: '#3388ff',
                        fillOpacity: 0.5
                    });
                    
                    polygon.bindPopup(createPopupContent(district));
                    return polygon;
                } else {
                    const marker = L.marker([district.lat, district.lng]);
                    marker.bindPopup(createPopupContent(district));
                    return marker;
                }
            } catch (error) {
                console.error(`Error creating layer for district "${district.name}":`, error);
                return null;
            }
        }

        // Convert GeoJSON to Leaflet format
        function convertGeoJsonToLeaflet(geoJson) {
            if (geoJson.type === 'Polygon') {
                return geoJson.coordinates.map(ring =>
                    ring.map(coord => [coord[1], coord[0]])
                );
            } else if (geoJson.type === 'MultiPolygon') {
                return geoJson.coordinates[0].map(polygon =>
                    polygon.map(coord => [coord[1], coord[0]])
                );
            }
            return [];
        }

        // Create popup content for district
        function createPopupContent(district) {
            const clusterInfo = currentClusters.length > 0 && district.id !== undefined && currentClusters[district.id] !== undefined
                ? `<p><strong>Cluster:</strong> ${currentClusters[district.id] + 1}</p>`
                : '';
            return `
                <div style="font-family: 'Segoe UI', sans-serif;">
                    <h4 style="margin: 0 0 10px 0; color: #2c3e50;">${district.name}</h4>
                    <p><strong>City:</strong> ${district.city}</p>
                    <p><strong>Order Qty:</strong> ${district.orderQty}</p>
                    ${clusterInfo}
                    <p><strong>Area:</strong> ${district.area.toFixed(2)} km¬≤</p>
                    <p><strong>Coordinates:</strong> ${district.lat.toFixed(4)}, ${district.lng.toFixed(4)}</p>
                </div>
            `;
        }

        // Generate clusters based on number of vans
        function generateClusters() {
            if (!currentData || currentData.length === 0) {
                showError('No data available!');
                return;
            }
            const loading = document.getElementById('loading');
            const nVans = parseInt(document.getElementById('vansInput').value, 10);
            if (isNaN(nVans) || nVans <= 0) {
                showError('Please enter a valid number of vans.');
                return;
            }
            
            loading.classList.add('show');
            setTimeout(() => {
                try {
                    const numClusters = nVans;
                    currentClusters = optimizedClustering(currentData, numClusters);
                    updateMapWithClusters();
                    updateClusterSummary();
                    updateStats();
                    showSuccess(`Generated ${numClusters} clusters successfully!`);
                } catch (error) {
                    showError('Error generating clusters: ' + error.message);
                } finally {
                    loading.classList.remove('show');
                }
            }, 500);
        }

        // Optimized clustering algorithm
        function optimizedClustering(districts, k) {
            if (!districts || districts.length === 0) return [];
            if (k >= districts.length) return districts.map((_, i) => i);

            // Sort districts by order quantity descending
            const sortedIdx = districts.map((_, i) => i)
                .sort((a, b) => districts[b].orderQty - districts[a].orderQty);

            // Initialize clusters with centroids (K-means++ style)
            const centroids = [];
            const clusters = Array(districts.length).fill(-1);
            const clusterOrderQty = Array(k).fill(0);

            // First centroid: the district with the highest order quantity
            centroids.push({...districts[sortedIdx[0]]});

            for (let i = 1; i < k; i++) {
                let maxDist = -1;
                let bestIdx = -1;
                
                for (let idx of sortedIdx) {
                    if (clusters[idx] !== -1) continue; // Skip if already assigned or selected as centroid
                    
                    let minDist = Infinity;
                    for (let c of centroids) {
                        const dist = getDistance(districts[idx], c);
                        minDist = Math.min(minDist, dist);
                    }
                    
                    if (minDist > maxDist) {
                        maxDist = minDist;
                        bestIdx = idx;
                    }
                }
                
                if (bestIdx !== -1) {
                    centroids.push({...districts[bestIdx]});
                } else {
                    // Fallback: if not enough distinct locations for k centroids, pick remaining sorted districts
                    for (let idx of sortedIdx) {
                        if (!centroids.some(c => c.id === districts[idx].id)) {
                            centroids.push({ ...districts[idx] });
                            if (centroids.length === k) break;
                        }
                    }
                }
            }

            // Calculate average distance for threshold
            const avgDist = calculateAverageDistance(districts);
            const maxAllowedDist = avgDist * 0.75; // Adjusted threshold

            // Assign districts to clusters
            for (let idx of sortedIdx) { // Process in order of order quantity
                let bestCluster = -1;
                let bestScore = Infinity;
                
                for (let c = 0; c < k; c++) {
                    const dist = getDistance(districts[idx], centroids[c]);
                    const distPenalty = dist > maxAllowedDist ? (dist - maxAllowedDist) * 100 : 0;
                    
                    const currentClusterQty = clusterOrderQty[c];
                    const score = (dist * 0.7) + (currentClusterQty * 0.001) + distPenalty;

                    if (score < bestScore) {
                        bestScore = score;
                        bestCluster = c;
                    }
                }
                
                if (bestCluster === -1) { // If no suitable cluster within distance threshold, find closest
                    bestCluster = findClosestCentroid(districts[idx], centroids);
                }
                
                clusters[idx] = bestCluster;
                clusterOrderQty[bestCluster] += districts[idx].orderQty;
            }

            // Refine clusters through iterative swapping
            refineClusters(districts, clusters, clusterOrderQty, centroids);

            return clusters;
        }

        // Calculate average distance between districts
        function calculateAverageDistance(districts) {
            let totalDist = 0;
            let count = 0;
            
            for (let i = 0; i < districts.length; i++) {
                for (let j = i + 1; j < districts.length; j++) {
                    totalDist += getDistance(districts[i], districts[j]);
                    count++;
                }
            }
            
            return count > 0 ? totalDist / count : 0;
        }

        // Find closest centroid for a district
        function findClosestCentroid(district, centroids) {
            let minDist = Infinity;
            let bestCluster = 0;
            
            for (let c = 0; c < centroids.length; c++) {
                const dist = getDistance(district, centroids[c]);
                if (dist < minDist) {
                    minDist = dist;
                    bestCluster = c;
                }
            }
            
            return bestCluster;
        }

        // Refine clusters through swapping
        function refineClusters(districts, clusters, clusterOrderQty, centroids) {
            let improved = true;
            let iterations = 0;
            const maxIterations = 100;

            while (improved && iterations < maxIterations) {
                improved = false;
                iterations++;

                // Recalculate cluster order quantities before swaps
                clusterOrderQty.fill(0);
                districts.forEach((district, idx) => {
                    const clusterId = clusters[idx];
                    if (clusterId !== -1) {
                        clusterOrderQty[clusterId] += district.orderQty;
                    }
                });

                for (let i = 0; i < districts.length; i++) {
                    for (let j = i + 1; j < districts.length; j++) {
                        const clusterI = clusters[i];
                        const clusterJ = clusters[j];

                        if (clusterI === clusterJ || clusterI === -1 || clusterJ === -1) continue;

                        const currentSpatialScore = getDistance(districts[i], centroids[clusterI]) + 
                                                  getDistance(districts[j], centroids[clusterJ]);
                        const newSpatialScore = getDistance(districts[i], centroids[clusterJ]) + 
                                              getDistance(districts[j], centroids[clusterI]);

                        if (newSpatialScore < currentSpatialScore) {
                            const currentImbalance = Math.abs(clusterOrderQty[clusterI] - clusterOrderQty[clusterJ]);
                            const tempQtyI = clusterOrderQty[clusterI] - districts[i].orderQty + districts[j].orderQty;
                            const tempQtyJ = clusterOrderQty[clusterJ] - districts[j].orderQty + districts[i].orderQty;
                            const newImbalance = Math.abs(tempQtyI - tempQtyJ);

                            if (newImbalance <= currentImbalance * 1.5) {
                                clusters[i] = clusterJ;
                                clusters[j] = clusterI;
                                clusterOrderQty[clusterI] = tempQtyI;
                                clusterOrderQty[clusterJ] = tempQtyJ;
                                improved = true;
                            }
                        }
                    }
                }
            }
        }

        // Calculate distance between two points
        function getDistance(point1, point2) {
            const latDiff = point1.lat - point2.lat;
            const lngDiff = point1.lng - point2.lng;
            return Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
        }

        // Update map with clusters
        function updateMapWithClusters() {
            if (!map || !currentData || currentData.length === 0) return;
            clearMapLayers();
            // Collect centroids
            const centroids = currentData.map(d => [d.lat, d.lng]);
            // Calculate mean and stddev
            const meanLat = centroids.reduce((sum, c) => sum + c[0], 0) / centroids.length;
            const meanLng = centroids.reduce((sum, c) => sum + c[1], 0) / centroids.length;
            const stdLat = Math.sqrt(centroids.reduce((sum, c) => sum + Math.pow(c[0] - meanLat, 2), 0) / centroids.length);
            const stdLng = Math.sqrt(centroids.reduce((sum, c) => sum + Math.pow(c[1] - meanLng, 2), 0) / centroids.length);
            // Only include centroids within 2 stddevs
            const filteredCentroids = centroids.filter(c =>
                Math.abs(c[0] - meanLat) <= 2 * stdLat &&
                Math.abs(c[1] - meanLng) <= 2 * stdLng
            );
            const bounds = L.latLngBounds([]);
            currentData.forEach((district, index) => {
                const clusterIndex = currentClusters[index];
                const color = clusterColors[clusterIndex % clusterColors.length];
                const layer = createClusterLayer(district, color, clusterIndex);
                if (layer) {
                    layer.addTo(map);
                    districtLayers.push(layer);
                    if (layer.getBounds) {
                        bounds.extend(layer.getBounds());
                    } else if (layer.getLatLng) {
                        bounds.extend(layer.getLatLng());
                    }
                }
            });
            // Fit to filtered centroids
            if (filteredCentroids.length > 0) {
                const centroidBounds = L.latLngBounds(filteredCentroids);
                map.fitBounds(centroidBounds, { padding: [20, 20] });
            } else if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [20, 20] });
            }
        }

        // Create cluster layer for map
        function createClusterLayer(district, color, clusterIndex) {
            try {
                if (district.geoJson?.coordinates) {
                    const leafletCoords = convertGeoJsonToLeaflet(district.geoJson);
                    const polygon = L.polygon(leafletCoords, {
                        color: color,
                        weight: 2,
                        fillColor: color,
                        fillOpacity: 0.5
                    });
                    
                    polygon.bindPopup(createPopupContent(district));
                    return polygon;
                } else {
                    const marker = L.marker([district.lat, district.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker',
                            html: `<div style="background-color: ${color}; border-radius: 50%; width: 20px; height: 20px; border: 2px solid white;"></div>`
                        })
                    });
                    
                    marker.bindPopup(createPopupContent(district));
                    return marker;
                }
            } catch (error) {
                console.error(`Error creating cluster layer for district "${district.name}":`, error);
                return null;
            }
        }

        // Update cluster summary
        function updateClusterSummary() {
            const clusterSummaryDiv = document.getElementById('clusterSummary');
            if (!currentClusters || !currentData || !clusterSummaryDiv) return;
            
            const uniqueClusterIds = [...new Set(currentClusters)].sort((a,b)=>a-b);
            const k = uniqueClusterIds.length;
            const totalOrders = currentData.reduce((sum, d) => sum + d.orderQty, 0);
            let summary = '';
            
            if (k === 0) {
                summary = `<p style="text-align: center; color: #666; font-style: italic;">No clusters generated yet. Click "Generate Clusters" to start.</p>`;
            } else {
                uniqueClusterIds.forEach(i => {
                    const clusterDistricts = currentData.filter((_, idx) => currentClusters[idx] === i);
                    const clusterOrders = clusterDistricts.reduce((sum, d) => sum + d.orderQty, 0);
                    const percent = totalOrders > 0 ? ((clusterOrders / totalOrders) * 100).toFixed(1) : 0;
                    const color = clusterColors[i % clusterColors.length];
                    
                    summary += `
                        <div style="display: flex; align-items: center; margin-bottom: 4px;">
                            <span style="display:inline-block;width:16px;height:16px;background:${color};border-radius:50%;margin-right:8px; border: 1px solid rgba(0,0,0,0.2);"></span>
                            <b style="color: #2c3e50;">Cluster ${i + 1}</b>
                            <span style="margin-left:12px; color:#666; font-size:13px;">Districts: ${clusterDistricts.length}</span>
                            <span style="margin-left:12px; color:#666; font-size:13px;">Orders: ${clusterOrders} (${percent}%)</span>
                        </div>
                        <ul style="margin:0 0 0 24px; padding:0; color:#555; font-size:14px; list-style-type: disc;">
                            ${clusterDistricts.map(d => `<li style="margin-bottom: 3px;">${d.name}</li>`).join('')}
                        </ul>
                    </div>
                    `;
                });
            }
            document.getElementById('clusterSummary').innerHTML = summary;
        }

        // New function: calculate shifts
        function calculateShifts() {
            if (!currentData || currentData.length === 0) {
                showError('No data available!');
                return;
            }

            const nVans = parseInt(document.getElementById('vansInput').value, 10);
            const pMax = parseInt(document.getElementById('parcelsInput').value, 10);

            if (isNaN(nVans) || nVans <= 0 || isNaN(pMax) || pMax <= 0) {
                showError('Please enter valid numbers for vans and parcels/van.');
                return;
            }

            // Prepare a flat list of parcels by district
            let districtParcels = currentData.map(d => ({
                name: d.name,
                districtRef: d,
                total: d.orderQty,
                remaining: d.orderQty,
                centroid: [d.lat, d.lng]
            }));

            // Calculate number of shifts
            const totalParcels = currentData.reduce((sum, d) => sum + d.orderQty, 0);
            const minShifts = Math.ceil(totalParcels / (nVans * pMax));
            let summary = `<p><strong>Total Parcels:</strong> ${totalParcels}</p>`;
            summary += `<p><strong>Minimum Shifts Needed:</strong> ${minShifts}</p>`;

            // Assign parcels to vans per shift using k-means
            shiftAssignments = [];
            let shifts = [];
            let districtsLeft = districtParcels.filter(d => d.remaining > 0);
            for (let shift = 0; shift < minShifts; shift++) {
                // Only cluster districts with remaining parcels
                let activeDistricts = districtsLeft.filter(d => d.remaining > 0);
                if (activeDistricts.length === 0) break;
                // Prepare data for k-means
                let data = activeDistricts.map(d => d.centroid);
                let k = Math.min(nVans, data.length);
                let clusters = mlKMeans(data, k);
                // Assign districts to clusters
                let clusterGroups = Array.from({ length: k }, () => []);
                clusters.clusters.forEach((clusterIdx, i) => {
                    clusterGroups[clusterIdx].push(activeDistricts[i]);
                });
                // For each cluster, assign up to pMax parcels to a van
                let vans = Array.from({ length: nVans }, () => ({ districts: [], parcels: 0 }));
                let vanUsed = 0;
                clusterGroups.forEach((group, cIdx) => {
                    let parcelsInCluster = group.reduce((sum, d) => sum + d.remaining, 0);
                    let parcelsToAssign = Math.min(parcelsInCluster, pMax);
                    let vanIdx = vanUsed < nVans ? vanUsed : 0;
                    vanUsed++;
                    // Assign parcels from districts in this cluster to the van
                    group.forEach(d => {
                        if (parcelsToAssign <= 0) return;
                        let assignCount = Math.min(d.remaining, parcelsToAssign);
                        vans[vanIdx].districts.push({
                            name: d.name,
                            districtRef: d.districtRef,
                            total: d.total,
                            count: assignCount,
                            split: d.total > pMax,
                            centroid: d.centroid
                        });
                        vans[vanIdx].parcels += assignCount;
                        d.remaining -= assignCount;
                        parcelsToAssign -= assignCount;
                    });
                });
                shifts.push(vans);
                shiftAssignments.push(vans);
                // Update districtsLeft for next shift
                districtsLeft = districtsLeft.filter(d => d.remaining > 0);
            }

            // Build UI for all shifts
            summary += `<div style='margin-top:18px;'>`;
            shifts.forEach((vans, shiftIdx) => {
                summary += `<h4 style='margin:18px 0 8px 0;'>Shift ${shiftIdx + 1}</h4>`;
                summary += `<table style="width:100%;border-collapse:collapse;margin-bottom:10px;">
                    <thead>
                        <tr style="background:#f0f0f0;">
                            <th style="padding:8px;border:1px solid #ddd;">Van</th>
                            <th style="padding:8px;border:1px solid #ddd;">Assigned Districts</th>
                            <th style="padding:8px;border:1px solid #ddd;">Total Parcels</th>
                        </tr>
                    </thead>
                    <tbody>`;
                vans.forEach((van, i) => {
                    summary += `<tr>
                        <td style="padding:8px;border:1px solid #ddd;font-weight:bold;text-align:center;">
                            <button class="button" style="padding:4px 12px;font-size:1em;min-width:60px;" onclick="highlightVan(${shiftIdx},${i})">Van ${i + 1}</button>
                        </td>
                        <td style="padding:8px;border:1px solid #ddd;">${van.districts.map(d => `<span class=\"district-tag\">${d.name}${d.split ? ` (${d.count})` : ''}</span>`).join(" ")}</td>
                        <td style="padding:8px;border:1px solid #ddd;text-align:center;">${van.parcels}</td>
                    </tr>`;
                });
                summary += `</tbody></table>`;
            });
            summary += `<div style='text-align:center;margin:10px 0;'><button class='button' style='background:#888;' onclick='showAllDistricts()'>Show All</button></div>`;
            summary += `</div>`;

            document.getElementById('shiftSummary').innerHTML = summary;
            showSuccess('Shift calculation complete!');
        }

        // Highlight districts for a van in a shift
        function highlightVan(shiftIdx, vanIdx) {
            if (!map || !shiftAssignments[shiftIdx] || !shiftAssignments[shiftIdx][vanIdx]) return;
            clearMapLayers();
            const van = shiftAssignments[shiftIdx][vanIdx];
            const color = shiftColors[shiftIdx % shiftColors.length];
            van.districts.forEach(chunk => {
                // Find the district object by name (chunk.districtRef)
                const district = chunk.districtRef;
                if (district && district.geoJson) {
                    const leafletCoords = convertGeoJsonToLeaflet(district.geoJson);
                    const polygon = L.polygon(leafletCoords, {
                        color: color,
                        weight: 2,
                        fillColor: color,
                        fillOpacity: 0.6
                    });
                    polygon.bindPopup(`<b>${district.name}</b><br>Parcels: ${chunk.count}${chunk.split ? ` (split from ${chunk.total})` : ''}`);
                    polygon.addTo(map);
                    districtLayers.push(polygon);
                }
            });
        }

        // Show all districts again
        function showAllDistricts() {
            updateMapWithClusters();
        }

        // Initialize application when page loads
        window.addEventListener('load', initApp);
    </script>
</body>
</html>
