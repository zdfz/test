<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>District Clustering Tool</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }

        .container {
            width: 100%;
            padding: 20px;
        }

        .content {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 20px;
        }

        .header h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 20px;
            font-size: 2rem;
            font-weight: 600;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 25px;
            border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .slider-label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 1rem;
        }

        .slider {
            width: 200px;
            height: 8px;
            border-radius: 5px;
            background: linear-gradient(to right, #667eea, #764ba2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            border: 3px solid #667eea;
        }

        .slider::-moz-range-thumb {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            border: 3px solid #667eea;
        }

        .cluster-value {
            font-weight: bold;
            color: #667eea;
            font-size: 1.2rem;
            background: white;
            padding: 8px 16px;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            min-width: 40px;
            text-align: center;
        }

        .button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .main-content {
            max-width: 1200px;
            margin: 20px auto;
            display: flex;
            gap: 20px;
            padding: 0 20px;
        }

        .map-container {
            flex: 2;
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            min-height: 600px;
        }

        #map {
            width: 100%;
            height: 600px;
        }

        .sidebar {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            max-height: 600px;
            overflow-y: auto;
        }

        .sidebar h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.3rem;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .cluster-info {
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-card .number {
            font-size: 1.5rem;
            font-weight: bold;
            display: block;
        }

        .stat-card .label {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        .error-message {
            background: #ff6b6b;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .success-message {
            background: #51cf66;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-weight: 600;
        }

        .loading.show {
            display: block;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .controls {
                flex-direction: column;
                gap: 15px;
            }
            
            .slider-container {
                flex-direction: column;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <div class="header">
                <h1>üó∫Ô∏è District Clustering Tool</h1>
            </div>
            
            <div class="controls">
                <div class="slider-container">
                    <span class="slider-label">Cluster Zones:</span>
                    <input type="range" min="5" max="20" value="10" class="slider" id="clusterSlider">
                    <span class="cluster-value" id="clusterValue">10</span>
                </div>
                <button class="button" id="generateBtn" onclick="generateClusters()">
                    Generate Clusters
                </button>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div class="map-container">
            <div id="map"></div>
        </div>
        
        <div class="sidebar">
            <div class="error-message" id="errorMessage"></div>
            <div class="success-message" id="successMessage"></div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <span class="number" id="totalDistricts">0</span>
                    <span class="label">Districts</span>
                </div>
                <div class="stat-card">
                    <span class="number" id="totalClusters">0</span>
                    <span class="label">Clusters</span>
                </div>
                <div class="stat-card">
                    <span class="number" id="totalOrders">0</span>
                    <span class="label">Total Orders</span>
                </div>
            </div>
            
            <h3>üìä Cluster Summary</h3>
            <div class="loading" id="loading">
                <p>üîÑ Processing data...</p>
            </div>
            <div id="clusterSummary">
                <p style="text-align: center; color: #666; font-style: italic;">
                    Upload an Excel file to get started
                </p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        // Global variables
        const clusterColors = [
            "#e6194b", "#3cb44b", "#ffe119", "#4363d8", "#f58231", "#911eb4", 
            "#46f0f0", "#f032e6", "#bcf60c", "#fabebe", "#008080", "#e6beff", 
            "#9a6324", "#fffac8", "#800000", "#aaffc3", "#808000", "#ffd8b1", 
            "#000075", "#808080", "#AA6E28", "#B57EDC", "#C0C0C0", "#FFD700",
            "#00FF00", "#00FFFF", "#FF00FF", "#8A2BE2", "#A52A2A", "#DEB887"
        ];
        
        let map;
        let currentData = null;
        let currentClusters = [];
        let districtLayers = [];

        // Initialize application
        function initApp() {
            initMap();
            setupEventListeners();
            loadExcelFile();
        }

        // Initialize map
        function initMap() {
            try {
                map = L.map('map').setView([26.3927, 50.0981], 11);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(map);
            } catch (error) {
                showError('Error initializing map: ' + error.message);
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            document.getElementById('clusterSlider').addEventListener('input', function(e) {
                document.getElementById('clusterValue').textContent = e.target.value;
            });
        }

        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => errorDiv.style.display = 'none', 8000);
        }

        // Show success message
        function showSuccess(message) {
            const successDiv = document.getElementById('successMessage');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            setTimeout(() => successDiv.style.display = 'none', 5000);
        }

        // Load Excel file
        function loadExcelFile() {
            const loading = document.getElementById('loading');
            loading.classList.add('show');

            fetch('districts_GeoJSON.xlsx')
                .then(response => response.arrayBuffer())
                .then(data => {
                    try {
                        const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
                        let allDistricts = processWorkbook(workbook);
                        
                        // Assign sequential IDs after all districts are gathered
                        allDistricts = allDistricts.map((d, index) => ({ ...d, id: index }));

                        if (allDistricts.length === 0) {
                            throw new Error('No valid districts found in the Excel file.');
                        }
                        
                        currentData = allDistricts;
                        updateStats();
                        updateMapWithDistricts();
                        showSuccess(`Loaded ${allDistricts.length} districts successfully!`);
                    } catch (error) {
                        showError('Error processing Excel file: ' + error.message);
                    } finally {
                        loading.classList.remove('show');
                    }
                })
                .catch(error => {
                    showError('Error loading Excel file: ' + error.message);
                    loading.classList.remove('show');
                });
        }

        // Process workbook data
        function processWorkbook(workbook) {
            let allDistricts = [];
            
            workbook.SheetNames.forEach(sheetName => {
                try {
                    const sheet = workbook.Sheets[sheetName];
                    const sheetData = XLSX.utils.sheet_to_json(sheet);
                    const districts = processSheetData(sheetData, sheetName);
                    allDistricts = allDistricts.concat(districts);
                } catch (sheetError) {
                    console.error(`Error processing sheet "${sheetName}":`, sheetError);
                }
            });
            
            return allDistricts;
        }

        // Process sheet data
        function processSheetData(sheetData, cityName) {
            return sheetData
                .map((row, index) => {
                    try {
                        const districtName = findColumnValue(row, [
                            'District name', 'District Name', 'district_name', 'district', 'District',
                            'name', 'Name', 'DISTRICT_NAME', 'DISTRICT'
                        ]) || `District ${index + 1}`;
                        
                        const geoJsonStr = findColumnValue(row, [
                            'GeoJSON', 'geojson', 'GeoJson', 'GEOJSON', 'geo_json', 'geometry'
                        ]);
                        
                        const orderQty = parseFloat(findColumnValue(row, [
                            'Order qty', 'Order Qty', 'order_qty', 'ORDER_QTY', 'orders', 'Orders',
                            'quantity', 'Quantity', 'qty', 'Qty'
                        ]) || 0);
                        
                        if (!geoJsonStr) return null;

                        const geoJson = parseGeoJson(geoJsonStr);
                        if (!geoJson) return null;

                        const { coords, isValid } = getGeoJsonCoordinates(geoJson);
                        if (!isValid) return null;

                        const { centroidLat, centroidLng } = calculateCentroid(coords);
                        if (isNaN(centroidLat)) return null;

                        return {
                            name: districtName,
                            city: cityName,
                            geoJson: geoJson,
                            lat: centroidLat,
                            lng: centroidLng,
                            orderQty: orderQty,
                            area: calculatePolygonArea(coords)
                        };
                    } catch (error) {
                        console.error(`Error processing district ${index}:`, error);
                        return null;
                    }
                })
                .filter(Boolean);
        }

        // Find value in row with flexible column name matching
        function findColumnValue(row, possibleNames) {
            for (const name of possibleNames) {
                if (row[name] !== null && row[name] !== undefined && row[name] !== '') {
                    return row[name];
                }
            }
            return null;
        }

        // Parse GeoJSON string
        function parseGeoJson(geoJsonStr) {
            try {
                return typeof geoJsonStr === 'string' ? JSON.parse(geoJsonStr) : geoJsonStr;
            } catch (e1) {
                try {
                    const cleaned = geoJsonStr
                        .replace(/^"|"$/g, '')
                        .replace(/""/g, '"');
                    return JSON.parse(cleaned);
                } catch (e2) {
                    return null;
                }
            }
        }

        // Get coordinates from GeoJSON
        function getGeoJsonCoordinates(geoJson) {
            let coords;
            
            if (geoJson.type === 'Polygon') {
                coords = geoJson.coordinates[0];
            } else if (geoJson.type === 'MultiPolygon') {
                coords = geoJson.coordinates[0][0];
            } else {
                return { coords: null, isValid: false };
            }
            
            const isValid = Array.isArray(coords) && coords.length >= 3;
            return { coords, isValid };
        }

        // Calculate centroid from coordinates
        function calculateCentroid(coords) {
            let totalLat = 0, totalLng = 0;
            
            coords.forEach(coord => {
                if (Array.isArray(coord) && coord.length >= 2) {
                    totalLng += parseFloat(coord[0]);
                    totalLat += parseFloat(coord[1]);
                }
            });
            
            return {
                centroidLat: totalLat / coords.length,
                centroidLng: totalLng / coords.length
            };
        }

        // Calculate polygon area
        function calculatePolygonArea(coordinates) {
            if (!coordinates || coordinates.length < 3) return 0;
            
            let area = 0;
            const n = coordinates.length;
            
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += coordinates[i][0] * coordinates[j][1];
                area -= coordinates[j][0] * coordinates[i][1];
            }
            
            const earthRadius = 6371;
            return (Math.abs(area) / 2) * (Math.PI / 180) ** 2 * earthRadius ** 2;
        }

        // Update statistics display
        function updateStats() {
            if (!currentData) return;
            
            document.getElementById('totalDistricts').textContent = currentData.length;
            document.getElementById('totalClusters').textContent = currentClusters.length > 0 
                ? new Set(currentClusters).size 
                : 0;
            document.getElementById('totalOrders').textContent = currentData.reduce((sum, d) => sum + d.orderQty, 0);
        }

        // Update map with districts
        function updateMapWithDistricts() {
            if (!map || !currentData || currentData.length === 0) return;
            
            clearMapLayers();
            
            const bounds = L.latLngBounds([]);
            
            currentData.forEach(district => {
                const layer = createDistrictLayer(district);
                if (layer) {
                    districtLayers.push(layer);
                    if (layer.getBounds) {
                        bounds.extend(layer.getBounds());
                    } else if (layer.getLatLng) {
                        bounds.extend(layer.getLatLng());
                    }
                }
            });
            
            if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [20, 20] });
            }
        }

        // Clear all map layers
        function clearMapLayers() {
            districtLayers.forEach(layer => {
                if (map.hasLayer(layer)) {
                    map.removeLayer(layer);
                }
            });
            districtLayers = [];
        }

        // Create district layer for map
        function createDistrictLayer(district) {
            try {
                if (district.geoJson?.coordinates) {
                    const leafletCoords = convertGeoJsonToLeaflet(district.geoJson);
                    const polygon = L.polygon(leafletCoords, {
                        color: '#333',
                        weight: 2,
                        fillColor: '#3388ff',
                        fillOpacity: 0.5
                    });
                    
                    polygon.bindPopup(createPopupContent(district));
                    return polygon;
                } else {
                    const marker = L.marker([district.lat, district.lng]);
                    marker.bindPopup(createPopupContent(district));
                    return marker;
                }
            } catch (error) {
                console.error(`Error creating layer for district "${district.name}":`, error);
                return null;
            }
        }

        // Convert GeoJSON to Leaflet format
        function convertGeoJsonToLeaflet(geoJson) {
            if (geoJson.type === 'Polygon') {
                return geoJson.coordinates.map(ring =>
                    ring.map(coord => [coord[1], coord[0]])
                );
            } else if (geoJson.type === 'MultiPolygon') {
                return geoJson.coordinates[0].map(polygon =>
                    polygon.map(coord => [coord[1], coord[0]])
                );
            }
            return [];
        }

        // Create popup content for district
        function createPopupContent(district) {
            const clusterInfo = currentClusters.length > 0 && district.id !== undefined && currentClusters[district.id] !== undefined
                ? `<p><strong>Cluster:</strong> ${currentClusters[district.id] + 1}</p>`
                : '';
            return `
                <div style="font-family: 'Segoe UI', sans-serif;">
                    <h4 style="margin: 0 0 10px 0; color: #2c3e50;">${district.name}</h4>
                    <p><strong>City:</strong> ${district.city}</p>
                    <p><strong>Order Qty:</strong> ${district.orderQty}</p>
                    ${clusterInfo}
                    <p><strong>Area:</strong> ${district.area.toFixed(2)} km¬≤</p>
                    <p><strong>Coordinates:</strong> ${district.lat.toFixed(4)}, ${district.lng.toFixed(4)}</p>
                </div>
            `;
        }

        // Generate clusters
        function generateClusters() {
            if (!currentData || currentData.length === 0) {
                showError('No data available!');
                return;
            }
            
            const loading = document.getElementById('loading');
            loading.classList.add('show');
            
            setTimeout(() => {
                try {
                    const numClusters = parseInt(document.getElementById('clusterSlider').value);
                    currentClusters = optimizedClustering(currentData, numClusters);
                    updateMapWithClusters();
                    updateClusterSummary();
                    updateStats();
                    showSuccess(`Generated ${numClusters} clusters successfully!`);
                } catch (error) {
                    showError('Error generating clusters: ' + error.message);
                } finally {
                    loading.classList.remove('show');
                }
            }, 500);
        }

        // Optimized clustering algorithm
        function optimizedClustering(districts, k) {
            if (!districts || districts.length === 0) return [];
            if (k >= districts.length) return districts.map((_, i) => i);

            // Sort districts by order quantity descending
            const sortedIdx = districts.map((_, i) => i)
                .sort((a, b) => districts[b].orderQty - districts[a].orderQty);

            // Initialize clusters with centroids (K-means++ style)
            const centroids = [];
            const clusters = Array(districts.length).fill(-1);
            const clusterOrderQty = Array(k).fill(0);

            // First centroid: the district with the highest order quantity
            centroids.push({...districts[sortedIdx[0]]});

            for (let i = 1; i < k; i++) {
                let maxDist = -1;
                let bestIdx = -1;
                
                for (let idx of sortedIdx) {
                    if (clusters[idx] !== -1) continue; // Skip if already assigned or selected as centroid
                    
                    let minDist = Infinity;
                    for (let c of centroids) {
                        const dist = getDistance(districts[idx], c);
                        minDist = Math.min(minDist, dist);
                    }
                    
                    if (minDist > maxDist) {
                        maxDist = minDist;
                        bestIdx = idx;
                    }
                }
                
                if (bestIdx !== -1) {
                    centroids.push({...districts[bestIdx]});
                } else {
                    // Fallback: if not enough distinct locations for k centroids, pick remaining sorted districts
                    for (let idx of sortedIdx) {
                        if (!centroids.some(c => c.id === districts[idx].id)) {
                            centroids.push({ ...districts[idx] });
                            if (centroids.length === k) break;
                        }
                    }
                }
            }

            // Calculate average distance for threshold
            const avgDist = calculateAverageDistance(districts);
            const maxAllowedDist = avgDist * 0.75; // Adjusted threshold

            // Assign districts to clusters
            for (let idx of sortedIdx) { // Process in order of order quantity
                let bestCluster = -1;
                let bestScore = Infinity;
                
                for (let c = 0; c < k; c++) {
                    const dist = getDistance(districts[idx], centroids[c]);
                    const distPenalty = dist > maxAllowedDist ? (dist - maxAllowedDist) * 100 : 0;
                    
                    const currentClusterQty = clusterOrderQty[c];
                    const score = (dist * 0.7) + (currentClusterQty * 0.001) + distPenalty;

                    if (score < bestScore) {
                        bestScore = score;
                        bestCluster = c;
                    }
                }
                
                if (bestCluster === -1) { // If no suitable cluster within distance threshold, find closest
                    bestCluster = findClosestCentroid(districts[idx], centroids);
                }
                
                clusters[idx] = bestCluster;
                clusterOrderQty[bestCluster] += districts[idx].orderQty;
            }

            // Refine clusters through iterative swapping
            refineClusters(districts, clusters, clusterOrderQty, centroids);

            return clusters;
        }

        // Calculate average distance between districts
        function calculateAverageDistance(districts) {
            let totalDist = 0;
            let count = 0;
            
            for (let i = 0; i < districts.length; i++) {
                for (let j = i + 1; j < districts.length; j++) {
                    totalDist += getDistance(districts[i], districts[j]);
                    count++;
                }
            }
            
            return count > 0 ? totalDist / count : 0;
        }

        // Find closest centroid for a district
        function findClosestCentroid(district, centroids) {
            let minDist = Infinity;
            let bestCluster = 0;
            
            for (let c = 0; c < centroids.length; c++) {
                const dist = getDistance(district, centroids[c]);
                if (dist < minDist) {
                    minDist = dist;
                    bestCluster = c;
                }
            }
            
            return bestCluster;
        }

        // Refine clusters through swapping
        function refineClusters(districts, clusters, clusterOrderQty, centroids) {
            let improved = true;
            let iterations = 0;
            const maxIterations = 100;

            while (improved && iterations < maxIterations) {
                improved = false;
                iterations++;

                // Recalculate cluster order quantities before swaps
                clusterOrderQty.fill(0);
                districts.forEach((district, idx) => {
                    const clusterId = clusters[idx];
                    if (clusterId !== -1) {
                        clusterOrderQty[clusterId] += district.orderQty;
                    }
                });

                for (let i = 0; i < districts.length; i++) {
                    for (let j = i + 1; j < districts.length; j++) {
                        const clusterI = clusters[i];
                        const clusterJ = clusters[j];

                        if (clusterI === clusterJ || clusterI === -1 || clusterJ === -1) continue;

                        const currentSpatialScore = getDistance(districts[i], centroids[clusterI]) + 
                                                  getDistance(districts[j], centroids[clusterJ]);
                        const newSpatialScore = getDistance(districts[i], centroids[clusterJ]) + 
                                              getDistance(districts[j], centroids[clusterI]);

                        if (newSpatialScore < currentSpatialScore) {
                            const currentImbalance = Math.abs(clusterOrderQty[clusterI] - clusterOrderQty[clusterJ]);
                            const tempQtyI = clusterOrderQty[clusterI] - districts[i].orderQty + districts[j].orderQty;
                            const tempQtyJ = clusterOrderQty[clusterJ] - districts[j].orderQty + districts[i].orderQty;
                            const newImbalance = Math.abs(tempQtyI - tempQtyJ);

                            if (newImbalance <= currentImbalance * 1.5) {
                                clusters[i] = clusterJ;
                                clusters[j] = clusterI;
                                clusterOrderQty[clusterI] = tempQtyI;
                                clusterOrderQty[clusterJ] = tempQtyJ;
                                improved = true;
                            }
                        }
                    }
                }
            }
        }

        // Calculate distance between two points
        function getDistance(point1, point2) {
            const latDiff = point1.lat - point2.lat;
            const lngDiff = point1.lng - point2.lng;
            return Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
        }

        // Update map with clusters
        function updateMapWithClusters() {
            if (!map || !currentData || currentData.length === 0) return;
            
            clearMapLayers();
            
            const bounds = L.latLngBounds([]);
            
            currentData.forEach((district, index) => {
                const clusterIndex = currentClusters[index];
                const color = clusterColors[clusterIndex % clusterColors.length];
                const layer = createClusterLayer(district, color, clusterIndex);
                
                if (layer) {
                    layer.addTo(map);
                    districtLayers.push(layer);
                    if (layer.getBounds) {
                        bounds.extend(layer.getBounds());
                    } else if (layer.getLatLng) {
                        bounds.extend(layer.getLatLng());
                    }
                }
            });
            
            if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [20, 20] });
            }
        }

        // Create cluster layer for map
        function createClusterLayer(district, color, clusterIndex) {
            try {
                if (district.geoJson?.coordinates) {
                    const leafletCoords = convertGeoJsonToLeaflet(district.geoJson);
                    const polygon = L.polygon(leafletCoords, {
                        color: color,
                        weight: 2,
                        fillColor: color,
                        fillOpacity: 0.5
                    });
                    
                    polygon.bindPopup(createPopupContent(district));
                    return polygon;
                } else {
                    const marker = L.marker([district.lat, district.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker',
                            html: `<div style="background-color: ${color}; border-radius: 50%; width: 20px; height: 20px; border: 2px solid white;"></div>`
                        })
                    });
                    
                    marker.bindPopup(createPopupContent(district));
                    return marker;
                }
            } catch (error) {
                console.error(`Error creating cluster layer for district "${district.name}":`, error);
                return null;
            }
        }

        // Update cluster summary
        function updateClusterSummary() {
            const clusterSummaryDiv = document.getElementById('clusterSummary');
            if (!currentClusters || !currentData || !clusterSummaryDiv) return;
            
            const uniqueClusterIds = [...new Set(currentClusters)].sort((a,b)=>a-b);
            const k = uniqueClusterIds.length;
            const totalOrders = currentData.reduce((sum, d) => sum + d.orderQty, 0);
            let summary = '';
            
            if (k === 0) {
                summary = `<p style="text-align: center; color: #666; font-style: italic;">No clusters generated yet. Click "Generate Clusters" to start.</p>`;
            } else {
                uniqueClusterIds.forEach(i => {
                    const clusterDistricts = currentData.filter((_, idx) => currentClusters[idx] === i);
                    const clusterOrders = clusterDistricts.reduce((sum, d) => sum + d.orderQty, 0);
                    const percent = totalOrders > 0 ? ((clusterOrders / totalOrders) * 100).toFixed(1) : 0;
                    const color = clusterColors[i % clusterColors.length];
                    
                    summary += `
                <div style="border-left: 6px solid ${color}; background: #f8f9fa; margin-bottom: 12px; padding: 10px 16px; border-radius: 6px; box-shadow: 0 2px 5px rgba(0,0,0,0.05);">
                  <div style="display: flex; align-items: center; margin-bottom: 4px;">
                    <span style="display:inline-block;width:16px;height:16px;background:${color};border-radius:50%;margin-right:8px; border: 1px solid rgba(0,0,0,0.2);"></span>
                    <b style="color: #2c3e50;">Cluster ${i + 1}</b>
                    <span style="margin-left:12px; color:#666; font-size:13px;">Districts: ${clusterDistricts.length}</span>
                    <span style="margin-left:12px; color:#666; font-size:13px;">Orders: ${clusterOrders} (${percent}%)</span>
                  </div>
                  <ul style="margin:0 0 0 24px; padding:0; color:#555; font-size:14px; list-style-type: disc;">
                    ${clusterDistricts.map(d => `<li style="margin-bottom: 3px;">${d.name}</li>`).join('')}
                  </ul>
                </div>
                `;
                });
            }
            document.getElementById('clusterSummary').innerHTML = summary;
        }

        // Initialize application when page loads
        window.addEventListener('load', initApp);
    </script>
</body>
</html>
